import matplotlib.pyplot as plt
# Import required packages
import math
import numpy as np
import matplotlib.pyplot as plt
import random
# Import required packages
import math
import numpy as np
import matplotlib.pyplot as plt
import random
# Import required packages
import math
import numpy as np
import matplotlib.pyplot as plt
import random
# e.g. scalar value function that takes scalar input and returns scalar output
def f(x):
return 3*x**2 - 4*x + 5
# e.g. single value
f(3.0)
# e.g. range of values
xs = np.arange(-5, 5, 0.25)
ys = f(xs)
ys
plt.plot(xs, ys)
h = 0.0000000001
x = 3.0
(f(x+h) - f(x))/h
a = 2.0
b = -3.0
c = 10.0
d1 = a*b + c
h = 0.0000001
#derivative wrt a
a += h
d2 = a*b + c
print('d1', d1)
print('d2', d2)
print('slope', (d2-d1)/h)
#derivative wrt b
b += h
a = 2.0
d2 = a*b + c
print('d1', d1)
print('d2', d2)
print('slope', (d2-d1)/h)
# e.g. scalar value function that takes scalar input and returns scalar output
def f(x):
return 3*x**2 - 4*x + 5
# e.g. single value
f(3.0)
# e.g. range of values
xs = np.arange(-5, 5, 0.25)
ys = f(xs)
ys
plt.plot(xs, ys)
h = 0.0000000001
x = 3.0
(f(x+h) - f(x))/h
a = 2.0
b = -3.0
c = 10.0
d1 = a*b + c
h = 0.0000001
#derivative wrt a
a += h
d2 = a*b + c
print('d1', d1)
print('d2', d2)
print('slope', (d2-d1)/h)
#derivative wrt b
b += h
a = 2.0
d2 = a*b + c
print('d1', d1)
print('d2', d2)
print('slope', (d2-d1)/h)
class Value:
def __init__(self, data, _children=(), _op='', label=''):
self.data = data
self.grad = 0.0
self._backward = lambda: None #default: nothing
self._prev = set(_children)
self._op = _op
self.label = label
# Nicer looking way to see what the value actually is instead of an object
def __repr__(self):
return f"Value(data={self.data})"
def __add__(self, other):
other = other if isinstance(other, Value) else Value(other)
out = Value(self.data + other.data, (self, other), '+')
def _backward():
self.grad += out.grad
other.grad += out.grad
out._backward = _backward
return out
def __radd__(self, other): # other * self
return self + other
def __mul__(self, other):
other = other if isinstance(other, Value) else Value(other)
out = Value(self.data * other.data, (self, other), '*')
def _backward():
self.grad += other.data * out.grad
other.grad += self.data * out.grad
out._backward = _backward
return out
def __rmul__(self, other): # other * self
return self * other
def tanh(self):
x = self.data
t = (math.exp(2*x)-1)/(math.exp(2*x)+1)
out = Value(t, (self, ), 'tanh')
def _backward():
self.grad +=  (1 - t**2) * out.grad
out._backward = _backward
return out
def exp(self):
x = self.data
out = Value(math.exp(x), (self, ), 'exp')
def _backward():
self.grad += out.data * out.grad
out._backward = _backward
return out
def __pow__(self, other):
assert isinstance(other, (int, float)), "only supporting int/float powers for now"
out = Value(self.data**other, (self,), f'**{other}')
def _backward():
self.grad += other * (self.data**(other-1)) * out.grad
out._backward = _backward
return out
def __truediv__(self, other): #self / other
return self * other**-1
def __neg__(self): # -self
return self * -1
def __sub__(self, other): # self - other
return self + (-other)
def backward(self):
topo = []
visited = set()
def build_topo(v):
if v not in visited:
visited.add(v)
for child in v._prev:
build_topo(child)
topo.append(v)
build_topo(self)
# call _backward() in the right topological order
self.grad = 1.0
for node in reversed(topo):
node._backward()
a = Value(2.0)
b = Value(4.0)
a-b
a = Value(2.0, label='a')
b = Value(-3.0, label='b')
c = Value(10.0, label='c')
e = a*b; e.label = 'e'
d = e + c; d.label = 'd'
f = Value(-2.0, label = 'f')
L = d * f; L.label = 'L'
L
d._prev
d._op
from graphviz import Digraph
def trace(root):
# builds a set of all nodes and edges in a graph
nodes, edges = set(), set()
def build(v):
if v not in nodes:
nodes.add(v)
for child in v._prev:
edges.add((child, v))
build(child)
build(root)
return nodes, edges
def draw_dot(root):
dot = Digraph(format='svg', graph_attr={'rankdir': 'LR'}) #LR = left to right
nodes, edges = trace(root)
for n in nodes:
uid = str(id(n))
# for any value in the graph, create a rectangular ('record') node for it
dot.node(name = uid, label = "{ %s | data %.4f | grad %.4f }" % (n.label, n.data, n.grad), shape = 'record')
if n._op:
# if this value is a result of some operation, create an op node for it
dot.node(name = uid + n._op, label = n._op)
# and connect this node to it
dot.edge(uid + n._op, uid)
for n1, n2 in edges:
# connect n1 to the op node of n2
dot.edge(str(id(n1)), str(id(n2)) + n2._op)
return dot
draw_dot(L)
