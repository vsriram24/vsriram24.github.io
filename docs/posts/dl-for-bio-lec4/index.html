<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vivek Sriram">
<meta name="dcterms.date" content="2025-11-24">
<meta name="description" content="Deep Learning in Biology - Week 4">

<title>Modeling Sequential Data (RNNs, LSTMs, and GRUs) – Home</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../vivek_cropped.JPG" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-4174EVHDM6"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4174EVHDM6', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Home</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About Me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">[VS]Codes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching and Mentorship</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../conferences.html"> 
<span class="menu-text">Presentations and Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications and Peer Review</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../blog.xml"> <i class="bi bi-rss" role="img" aria-label="RSS">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Modeling Sequential Data (RNNs, LSTMs, and GRUs)</h1>
                  <div>
        <div class="description">
          Deep Learning in Biology - Week 4
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Overviews</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vivek Sriram </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 24, 2025</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">November 24, 2025</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#challenges-with-sequences" id="toc-challenges-with-sequences" class="nav-link active" data-scroll-target="#challenges-with-sequences">Challenges with sequences</a></li>
  <li><a href="#from-statistical-to-neural-models" id="toc-from-statistical-to-neural-models" class="nav-link" data-scroll-target="#from-statistical-to-neural-models">From statistical to neural models</a></li>
  <li><a href="#recurrent-neural-networks-rnns" id="toc-recurrent-neural-networks-rnns" class="nav-link" data-scroll-target="#recurrent-neural-networks-rnns">Recurrent Neural Networks (RNNs)</a></li>
  <li><a href="#lstms-solving-long-range-dependencies" id="toc-lstms-solving-long-range-dependencies" class="nav-link" data-scroll-target="#lstms-solving-long-range-dependencies">LSTMs: solving long-range dependencies</a></li>
  <li><a href="#grus-simpler-faster-alternatives" id="toc-grus-simpler-faster-alternatives" class="nav-link" data-scroll-target="#grus-simpler-faster-alternatives">GRUs: simpler, faster alternatives</a></li>
  <li><a href="#rnn-extensions" id="toc-rnn-extensions" class="nav-link" data-scroll-target="#rnn-extensions">RNN extensions</a></li>
  <li><a href="#language-modeling-with-rnns" id="toc-language-modeling-with-rnns" class="nav-link" data-scroll-target="#language-modeling-with-rnns">Language modeling With RNNs</a></li>
  <li><a href="#where-rnns-still-matter" id="toc-where-rnns-still-matter" class="nav-link" data-scroll-target="#where-rnns-still-matter">Where RNNs still matter</a></li>
  <li><a href="#closing-thoughts" id="toc-closing-thoughts" class="nav-link" data-scroll-target="#closing-thoughts">Closing thoughts</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>From DNA sequences and patient timelines to speech, text, and sensor data, much of the world’s information arrives as sequences: ordered data where context matters. While architectures like CNNs revolutionized image comprehension, they were not built to handle the fluid, variable-length nature of sequential inputs.</p>
<p>This week in my Deep Learning in Biology overview series, we dive into one of the foundational ideas in modern AI: Recurrent Neural Networks (RNNs) and their powerful extensions, LSTMs and GRUs. Understanding RNNs is essential for grasping the evolution of not just recent sequence models, but also the architectures that ultimately replaced them.</p>
<p><img src="images/redbluff.jpg" class="img-fluid" width="388"></p>
<section id="challenges-with-sequences" class="level2">
<h2 class="anchored" data-anchor-id="challenges-with-sequences">Challenges with sequences</h2>
<p>A sequence refers to an ordered structure of information. Small changes in order can completely change meaning. However, sequences introduce several challenges:</p>
<ul>
<li><p>Variable lengths: Biological measurements, clinical notes, and sentences all differ in size.</p></li>
<li><p>Context dependencies: The meaning of each element depends on what came before (and sometimes after).</p></li>
<li><p>High dimensionality: Inputs often contain multivariate or semantic structure.</p></li>
<li><p>Noise and missingness: Real-world biological and clinical data often include incorrect information and/or missining data points, which can complicate appropriate interpretation of data.</p></li>
</ul>
<p>What we really want is a probabilistic model that can assign a meaningful likelihood to each possible sequence. This is the motivation behind Recurrent Neural Networks (RNNs).</p>
</section>
<section id="from-statistical-to-neural-models" class="level2">
<h2 class="anchored" data-anchor-id="from-statistical-to-neural-models">From statistical to neural models</h2>
<p>Before deep learning, sequence modeling (including machine translation, also known as ‘MT’) was dominated by statistical methods. Early systems involved Rule-based MT (RMT) and were focused on hand-crafted linguistic rules. The follow-up to this approach was Statistical MT (SMT), and relied heavily on Bayes’ rule - separate models were developed to handle both fidelity (quality of translation) and fluency (quality of language).</p>
<p>With the advent of deep learning, Neural Machine Translation (NMT) replaced this pipeline with end-to-end training, learning representations, alignment, and translation jointly. The same shift happened across NLP, speech, and biological sequence analysis.</p>
</section>
<section id="recurrent-neural-networks-rnns" class="level2">
<h2 class="anchored" data-anchor-id="recurrent-neural-networks-rnns">Recurrent Neural Networks (RNNs)</h2>
<p>A standard neural network expects fixed-size inputs and cannot “remember” earlier computations. RNNs solve this through <em>recurrence</em>:</p>
<ul>
<li><p>The same weight matrix is applied at every timestep.</p></li>
<li><p>A hidden state carries forward information through the sequence.</p></li>
<li><p>The model size stays constant, no matter how long the sequence is.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/rnn.png" class="img-fluid figure-img"></p>
<figcaption>An overview of the RNN architecture - Wikimedia Commons</figcaption>
</figure>
</div>
<p>This symmetry makes RNNs the first neural architecture capable of handling arbitrary-length sequential data (both with respect to input and output). RNNs can thus be used to model temporal dependencies, as well as represent both local and global patterns in the data.</p>
<p>In spite of these advances in terms of handling sequential data, many challenges still exist. It is difficult for RNNs to access distant information across input sequences, creating limitations in long-range dependency modeling. RNNs are also memory-intensive and take a long time to train.</p>
<p>Lastly, as we described in last week’s overview, RNNs are prone to both vanishing and exploding gradients. Vanishing gradients refer to the challenge where gradient signals shrink exponentially as they travel backward through the network. As a result, the RNN will end up focusing only on short-term dependencies, effectively ignoring any long-range context. On the other hand, exploding gradients refer to the “blowing up” of gradient norms, causing unstable updates in the process. These can lead to inappropriate training jumps that prevent the model from settling on the right minimal loss.</p>
<p>Solutions to both of these challenges include careful initialization of model parameters, gradient clipping, gradient normalization, residual and skip connections, and most importantly, <strong>gated architectures</strong>.</p>
</section>
<section id="lstms-solving-long-range-dependencies" class="level2">
<h2 class="anchored" data-anchor-id="lstms-solving-long-range-dependencies">LSTMs: solving long-range dependencies</h2>
<p>Long Short-Term Memory (LSTM) networks introduce a clever mechanism to the RNN architecture: gates that control information flow. Each timestep maintains:</p>
<ul>
<li><p>a cell state (accounting for long-term memory)</p></li>
<li><p>a hidden state (accounting for short-term output)</p></li>
</ul>
<p>Furthermore, each timestep includes each of the following three gates:</p>
<ul>
<li><p>a forget gate: what to erase</p></li>
<li><p>an input gate: what to store</p></li>
<li><p>and an output gate: what to reveal</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/LSTM_3.svg" class="img-fluid figure-img"></p>
<figcaption>The LSTM gating architecture - Wikimedia Commons</figcaption>
</figure>
</div>
<p>This gating process generates gradients to flow more cleanly across many timesteps, solving the vanishing gradient problem and enabling models to capture long-term structure.</p>
</section>
<section id="grus-simpler-faster-alternatives" class="level2">
<h2 class="anchored" data-anchor-id="grus-simpler-faster-alternatives">GRUs: simpler, faster alternatives</h2>
<p>No, this is not Gru from “Despicable Me”… The Gated Recurrent Unit (GRU) model simplifies LSTMs by combining the input and forget gates into a single update gate. Furthermore, a reset gate is used to control past information. The fewer parameters included in this architecture result in faster training. Furthermore, despite being simpler models, GRUs often perform just as well as if not better than LSTMs, especially on medium-sized datasets.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Gated_Recurrent_Unit_3.svg" class="img-fluid figure-img"></p>
<figcaption>The GRU gating architecture - Wikimedia Commons</figcaption>
</figure>
</div>
</section>
<section id="rnn-extensions" class="level2">
<h2 class="anchored" data-anchor-id="rnn-extensions">RNN extensions</h2>
<p>Further modifications can be made to the RNN architecture to improve the way that sequential data are represented.</p>
<p><strong>Bidirectional RNNs</strong> process sequences forward and backward, allowing the model to consider context from both the past and future. This model architecture is great for tasks where the whole sequence is available (e.g.&nbsp;named entity recognition, text classification) but is not well-suited for real-time tasks.</p>
<p><strong>Stacked RNNs</strong> use the layers of recurrence to add a hierarchical modeling aspect to the data. As a result, they can capture increasingly abstract temporal patterns. Skip connections can be used as well to reduce training time and memory requirements in very deep architectures.</p>
</section>
<section id="language-modeling-with-rnns" class="level2">
<h2 class="anchored" data-anchor-id="language-modeling-with-rnns">Language modeling With RNNs</h2>
<p>Before Transformers, RNNs powered the best language models. The pipeline for language modeling with RNNs included the following steps:</p>
<ol type="1">
<li>Tokenize text</li>
<li>Build the vocabulary for the corpus</li>
<li>Convert words to IDs</li>
<li>Load word embeddings</li>
<li>Feed sequence of words to the RNN</li>
<li>Predict the next word (using softmax probabilities)</li>
<li>Compute loss with cross-entropy</li>
<li>Train the RNN via backpropagation through time (BPTT)</li>
</ol>
<p>A variety of embedding methods (e.g.&nbsp;Word2Vec, GloVe, FastText, Transformer embeddings) can be applied to map words to dense vectors that semantic relationships.</p>
<p>Furthermore, language models can be evaluated using the following metrics:</p>
<ul>
<li><p>Perplexity (text prediction accuracy)</p></li>
<li><p>BLEU/ROUGE/METEOR (language translation / similarity)</p></li>
<li><p>Accuracy/F1 (text classification)</p></li>
<li><p>Human evaluation (coherence/fluency)</p></li>
</ul>
<p>We will delve more into word embedding and evaluation metrics for language models when we discuss Transformers in the future.</p>
</section>
<section id="where-rnns-still-matter" class="level2">
<h2 class="anchored" data-anchor-id="where-rnns-still-matter">Where RNNs still matter</h2>
<p>While Transformers dominate the cutting-edge of NLP today, RNNs remain valuable for a variety of scenarios and tasks, including small-data regimes, low-latency applications, and resource-limited environments.</p>
<p>RNNs also come into play for situations like continuous control tasks (controlling an agent in a real-world environment where actions/states are continuous) or problems where inductive biases around continuity or recurrence are useful (i.e.&nbsp;biological signals like ECG/EEG).</p>
</section>
<section id="closing-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="closing-thoughts">Closing thoughts</h2>
<p>RNNs, and in particular, LSTMs and GRUs, were the first deep learning architectures truly capable of effectively representing sequential data. They transformed NLP, speech recognition, and biological sequence analysis, paving the way for the attention mechanisms and Transformer models that followed.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/vsriram24\.github\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="vsriram24/vsriram24.github.io" data-repo-id="PLACEHOLDER" data-category="Blog Comments" data-category-id="PLACEHOLDER" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" data-loading="lazy" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="light">
</div> <!-- /content -->




</body></html>