{
  "hash": "32a88f42f51c382d8ccff89887f4eeb2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Correcting batch effects in single cell RNA-seq data with Monocle 3\"\ndescription: \"Takeaways from the SASC User Group Workshop #2\"\nauthor: \"Vivek Sriram\"\ndate: \"5/27/2024\"\ndate-modified: \"5/27/2024\"\nimage: IMG_7480.jpg\ncategories:\n  - Tutorials\ndraft: true\n---\n\n\nIn this week's blog, I'll be summarizing takeaways and a code example from the Seattle Area Single Cell ([SASC](http://www.brotmanbatyinstitute.org/news/seattle-area-single-cell-user-group-to-launch-february-13)) User Group's second workshop of the year, which was held on May 16th, 2024. Slides from the workshop can be found [here](https://mcusercontent.com/866d1ce75e95c7523153ac12f/files/269008ef-2e56-30f4-9464-7793817a7a0d/SASC_Presentation_05162024.pdf).\n\nThe SASC User Group, directed by Dr. [Mary O'Neill](https://www.linkedin.com/in/oneillmb1/) at the [Brotman Baty Institute](http://brotmanbaty.org), is designed to create connections and foster community among single-cell researchers at Fred Hutch, UW Medicine, Seattle Children's, as well as other Seattle-area researchers working with single-cell data. If you are interested in joining the group, you can subscribe to their listserv [here](https://mailchi.mp/668c21581425/seattle-area-single-cell-sasc). The group holds quarterly meetings rotating across the three campuses, each with a different focus. May's workshop was dedicated to applying batch correction methods using *Monocle 3* to analyze [single-cell RNA-seq](https://www.illumina.com/techniques/sequencing/rna-sequencing/ultra-low-input-single-cell-rna-seq.html#:~:text=Single%2Dcell%20sequencing%20is%20a,cell%2Dto%2Dcell%20variation) (scRNA-seq) data.\n\n![](SASC.png)\n\nAll credit for the data and code in this workshop goes to Mary and the folks at the BBI who helped organize this community. I have simply summarized their content and added a few clarifiers in various sections! I claim no significant knowledge myself of working with single cell data - in the future, I hope to release a post that highlights some more of the biological context highlighted through this workshop. You can follow along with the original tutorial and code example at the SASC GitHub page [here](https://github.com/bbi-lab/SASC/tree/main).\n\nAnd so, with context out of the way, let's get started!\n\n------------------------------------------------------------------------\n\n# 1. Background\n\n[Monocle 3](https://cole-trapnell-lab.github.io/monocle3/) is \"an analysis toolkit for single-cell RNA-seq data\", developed by the [Trapnell Lab](https://cole-trapnell-lab.github.io) at the University of Washington Department of Genome Sciences.\n\nWhen analyzing any form of data, especially single cell data, it is important to keep the right sources of variation (see [Aquino, Bisiaux, Li et al., Nature 2024](https://www.nature.com/articles/s41586-023-06422-9)). Batch effects refer to technical, non-biological factors that cause variation in data, and must be appropriately addressed to avoid confounding in results.\n\nThe best way to get around batch effects is to avoid introducing them in the first place! Nothing can salvage a poor study design. In a similar vein, it is important to determine whether or not there are actually batch effects in the first place that are influencing your data. Sometimes, batch corrections can introduce more artifacts than they alleviate. So, when applying batch correction methods, apply them thoughtfully. Know what they are doing, what to use them for, and where they can lead you astray.\n\nA variety of batch correction methods exist for scRNA-seq data (see [Antonsson, Melsted, bioRXiv 2024](https://www.biorxiv.org/content/10.1101/2024.03.19.585562v1)). Generally, single cell analysis falls into two camps:\n\n1.  Batch correction is only for visualization. The batch category is used as a covariate in downstream analysis\n\n2.  Batch correction is incorporated into the data processing pipeline. Batch corrected data are used in downstream analysis.\n\nFor our code example, the data we are using represent a subset of heart data generated by the BBI after processing through [Scale Biosciences](https://scale.bio)' and [Parse Biosciences](https://www.parsebiosciences.com/?utm_term=parse%20bio&utm_campaign=SO-Brand&utm_source=adwords&utm_medium=ppc&hsa_acc=2102361796&hsa_cam=13426955429&hsa_grp=132369215427&hsa_ad=559252349451&hsa_src=g&hsa_tgt=kwd-1180951410162&hsa_kw=parse%20bio&hsa_mt=e&hsa_net=adwords&hsa_ver=3&gad_source=1&gbraid=0AAAAAChPTjeBWJ0X988olMLq6sXDSGQfp&gclid=EAIaIQobChMI26DP16mfhgMVIQetBh2-2gwSEAAYASAAEgKMnvD_BwE)' respective single-cell sequencing assays. The same samples are used in both assays - each sample had two different donors. Data were mixed together, and then genetic demultiplexing was performed.\n\nWe start off by calling our required packages for analysis. In this case, we are using R version 4.4.0. Refer to the following links (or the [SASC GitHub page](https://github.com/bbi-lab/SASC/tree/main)) for help with installing required packages:\n\n-   [Bioconductor Installation](https://www.bioconductor.org/install/)\n\n-   [Monocle 3 Installation](https://cole-trapnell-lab.github.io/monocle3/docs/installation/)\n\n-   [kBET Installation](https://github.com/theislab/kBET)\n\n-   [Harmony Installation](https://github.com/immunogenomics/harmony)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"~/Documents/Developer/vsriram24.github.io/posts/sasc-workshop2\")\n\n#load required packages\nlibrary(monocle3)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(viridis)\nlibrary(randomcoloR)\nlibrary(kBET)\nlibrary(cowplot)\nlibrary(harmony)\nlibrary(uwot)\nlibrary(batchelor)\n```\n:::\n\n\n# 2. Reading in the data\n\nWith our environment ready to go, we start by reading in our input scRNA-seq data. This dataset is in the form of an S4 object, the standard format for representing sequencing data in *Monocle 3*. Other packages such as [Seurat](https://satijalab.org/seurat/) will have their own file formats to represent data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Read in the cell data set containing a random sub-sampling of 35K barcodes from\nsasc <- readRDS(\"BBI_heart_hs_mix_36601humangenes_35000barcodes.RDS\")\n```\n:::\n\n\nWe can use the *detect_genes* function to count how many cells in our data are expressed above a minimum threshold.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsasc <- detect_genes(sasc)\n\nexpressed <- data.frame(rowData(sasc)) %>% \n  arrange(desc(num_cells_expressed))\n```\n:::\n\n\nWe then use the *n.umi* attribute from the output of detect_genes to see how many unique molecular identifiers ([UMIs](https://www.illumina.com/techniques/sequencing/ngs-library-prep/multiplexing/unique-molecular-identifiers.html)) are in our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sasc$n.umi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    100     306     837    2084    2311  179927 \n```\n\n\n:::\n:::\n\n\nLooking at the donor attribute of our data, and we see that there are numerous doublet (appearing for both donors) as well as unassigned (appearing for neither donor) UMIs in our data that may belong to either of our donors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(sasc$donor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n         0          1    doublet unassigned \n     16410      14938        274       3378 \n```\n\n\n:::\n:::\n\n\nWe are also able to see the breakdown of UMIs processed by our Parse and Scale scRNA-seq assays respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(sasc$batch)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nParse Scale \n16263 18737 \n```\n\n\n:::\n:::\n\n\n# 3. Quality control\n\nNow that we have a breakdown of our data, we can perform quality control.\n\nWe start by calculating the mitochondrial DNA content in our scRNA-seq data. The presence of mitochondrial DNA (mtDNA) in our data represents [low quality calls](https://kb.10xgenomics.com/hc/en-us/articles/360026508452-How-can-I-exclude-poor-quality-cells-such-as-those-that-show-enrichment-of-MT-genes).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Search for genes with \"MT\" in their name.\nfData(sasc)$MT <- grepl(\n  \"MT-\", \n  rowData(sasc)$gene_short_name\n)\n\ntable(fData(sasc)$MT)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n36588    13 \n```\n\n\n:::\n:::\n\n\nBased upon the mitochondrial DNA content we calculated, we can evaluate the percentage of mitochondrial reads in our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npData(sasc)$MT_reads <- Matrix::colSums(exprs(sasc)[fData(sasc)$MT,])\npData(sasc)$MT_perc <- pData(sasc)$MT_reads/Matrix::colSums(exprs(sasc))*100\n\nsummary(sasc$MT_perc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.1303  0.9560  2.8839  3.2258 61.3861       1 \n```\n\n\n:::\n:::\n\n\nWith our calculated mitochondrial percentages, we can start to visualize our data.\n\nLet's look at a plot of genes by UMIs, colored by mitochondrial percentage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data.frame(pData(sasc)), \n  aes(x = n.umi, y = num_genes_expressed)) +\n  facet_wrap(~batch, nrow = 1) +\n  geom_point(size = 0.5, alpha = 0.3, aes(color = MT_perc)) +\n  theme_light() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14),\n        axis.title = element_text(size = 16),\n        axis.text.y = element_text(size = 14),\n        aspect.ratio = 1) +\n  scale_color_viridis() +\n  xlab(\"UMIs\") +\n  ylab(\"Number of Genes Captured\") +\n  scale_y_log10() +\n  scale_x_log10() +\n  geom_abline(slope = 1, color = \"grey\") +\n  geom_hline(yintercept = 200, linetype = \"dotted\", color = \"red\") +\n  geom_vline(xintercept = 300, linetype = \"dotted\", color = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nWe can see that in spite of the fact that our two samples were identical, different mitochondrial content are exhibited across our assays. In particular, we see a lot of noise for the UMIs that correspond to under 200 genes.\n\nNow let's look at mitochondrial percentage by donor type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data.frame(pData(sasc)), \n  aes(x = donor, y = MT_perc)) +\n  facet_wrap(~batch, nrow = 1, drop = TRUE, scales = \"free_x\") +\n  geom_violin(aes(fill = batch)) +\n  geom_boxplot(notch = T, fill = \"white\", width = 0.25, alpha = 0.3, outlier.shape = NA) +\n  theme_light() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14),\n        axis.title = element_text(size = 16),\n        axis.text.y = element_text(size = 14)) +\n  xlab(\"\") +\n  ylab(\"MT %\") +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNotch went outside hinges\nℹ Do you want `notch = FALSE`?\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nWe again see differences across our assays here in terms of MT percentage - in particular, it seems like we would want to have mitochondrial percentage no greater than 10% in our data.\n\nNow let's look at UMIs by donor type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data.frame(pData(sasc)), \n  aes(x = donor, y = n.umi)) +\n  facet_wrap(~batch, nrow = 1, drop = TRUE, scales = \"free_x\") +\n  geom_violin(aes(fill = batch)) +\n  geom_boxplot(notch = T, fill = \"white\", width = 0.25, alpha = 0.3, outlier.shape = NA) +\n  theme_light() +\n  geom_hline(yintercept = 300, linetype = \"dashed\", color = \"blue\") + #change to thresholds\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14),\n        axis.title = element_text(size=16),\n        axis.text.y = element_text(size = 14)) +\n  scale_y_log10() +\n  xlab(\"\") +\n  ylab(\"UMIs\") +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nHere, it seems like data are hard to differentiate under a certain number of UMIs (in this case, 300).\n\nSo, let's establish a QC filter for our data: 300 UMIs, 200 genes, and over 10% mitochondrial content.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Let's remove everything under 300 UMIs, 200 genes, and over 10% mitochondrial percentage\nsasc$qcflag <- ifelse(\n  sasc$n.umi >= 300 & \n  sasc$num_genes_expressed >= 200 & \n  sasc$MT_perc < 10, \n  \"PASS\", \n  \"FAIL\"\n)\n\ntable(sasc$qcflag)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n FAIL  PASS \n10180 24820 \n```\n\n\n:::\n\n```{.r .cell-code}\nsasc <- sasc[,sasc$qcflag == \"PASS\"] #filter out failing barcodes\nsasc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: cell_data_set \ndim: 36601 24820 \nmetadata(1): cds_version\nassays(1): counts\nrownames(36601): ENSG00000243485 ENSG00000237613 ... ENSG00000278817\n  ENSG00000277196\nrowData names(6): id gene_short_name ... num_cells_expressed MT\ncolnames(24820): AGGATAATCTCGGCCTTACAGGTCAGCTT 22_60_95__s4 ...\n  24_87_10__s1 20_17_34__s4\ncolData names(12): barcode n.umi ... MT_perc qcflag\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\nLet's also remove UMIs that were mapped to the wrong genome, nonassignable to a donor, or deemed a doublet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsasc <- sasc[,sasc$organism == \"human\" & sasc$donor %in% c(0, 1)]\nsasc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: cell_data_set \ndim: 36601 24216 \nmetadata(1): cds_version\nassays(1): counts\nrownames(36601): ENSG00000243485 ENSG00000237613 ... ENSG00000278817\n  ENSG00000277196\nrowData names(6): id gene_short_name ... num_cells_expressed MT\ncolnames(24216): AGGATAATCTCGGCCTTACAGGTCAGCTT 22_60_95__s4 ...\n  24_87_10__s1 20_17_34__s4\ncolData names(12): barcode n.umi ... MT_perc qcflag\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\nFinally, we have our semi-cleaned data!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(sasc$batch)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nParse Scale \n11474 12742 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(sasc$batch, sasc$donor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       \n           0    1 doublet unassigned\n  Parse 8637 2837       0          0\n  Scale 4506 8236       0          0\n```\n\n\n:::\n:::\n\n\n# 4. Pre-processing and data visualization\n\nAfter completing quality control of our data, we can start to pre-process it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove non-expressed/non-captured genes \nhist(fData(sasc)$num_cells_expressed)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nWe can also conduct feature selection for genes if we want. This step is not necessary in every case, but it can help with reducing computational loads. Here, we filter out genes that are not expressed in at least 25 cells.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(fData(sasc)$num_cells_expressed > 25)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n15315 21286 \n```\n\n\n:::\n\n```{.r .cell-code}\n# filter out genes not expressed in at least 25 cells\nsasc <- sasc[fData(sasc)$num_cells_expressed > 25, ]\nsasc \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: cell_data_set \ndim: 21286 24216 \nmetadata(1): cds_version\nassays(1): counts\nrownames(21286): ENSG00000238009 ENSG00000241860 ... ENSG00000278817\n  ENSG00000277196\nrowData names(6): id gene_short_name ... num_cells_expressed MT\ncolnames(24216): AGGATAATCTCGGCCTTACAGGTCAGCTT 22_60_95__s4 ...\n  24_87_10__s1 20_17_34__s4\ncolData names(12): barcode n.umi ... MT_perc qcflag\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\nNow we apply the *estimate_size_factors* function from *Monocle 3* to [evaluate the relative bias in each cell](https://bioconductor.org/books/3.17/OSCA.basic/normalization.html#).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsasc <- estimate_size_factors(sasc)\n```\n:::\n\n\nAfter estimating size factors, we can run *preprocess_cds*, a standardized workflow in the *Monocle 3* package that normalizes the data by log and size factor to address depth differences, and then calculates a lower dimensional space that will be used as the input for further dimensionality reduction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1000)\nsasc <- preprocess_cds(sasc) #this may take a few minutes\n```\n:::\n\n\nWe can then call *reduce_dimensions* from *Monocle 3* on our data to get down to the most relevant components.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1000)\nsasc <- reduce_dimension(sasc) #this may take a few minutes\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo preprocess_method specified, using preprocess_method = 'PCA'\n```\n\n\n:::\n:::\n\n\nNow let's plot the cells in our data (first colored by batch and then by donor)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(sasc, color_cells_by = \"batch\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo trajectory to plot. Has learn_graph() been called yet?\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot_cells(sasc, color_cells_by = \"donor\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo trajectory to plot. Has learn_graph() been called yet?\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-2.png){width=672}\n:::\n:::\n\n\nWe now have our dimensionality-reduced data! Let's use k-means clustering to categorize our cells into clusters.\n\nOne can (and should) spend a lot of time tweaking their clustering parameters. In this situation, we'll go with a k of 40 for Leiden clustering. It is advisable to try several k-values and/or resolutions during this exploratory data analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsasc <- cluster_cells(\n  sasc, \n  k=40, \n  cluster_method=\"leiden\", \n  random_seed=1000\n) #this may take a few minutes\n\n# add cluster information for each cell\ncolData(sasc)$k40_leiden_clusters = clusters(sasc) \n\nplot_cells(sasc)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nLet's get the top marker genes based on our Leiden clustering:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_marker_genes <- top_markers(\n  sasc, \n  group_cells_by=\"k40_leiden_clusters\"\n)\n\nkeep <- top_marker_genes %>%\n  filter(fraction_expressing >= 0.30) %>%\n  group_by(cell_group) %>%\n  top_n(3, marker_score) %>%\n  pull(gene_short_name) %>%\n  unique()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_genes_by_group(\n  sasc,\n  c(keep),\n  group_cells_by = \"k40_leiden_clusters\", #\"partition\", \"cluster\"\n  ordering_type = \"maximal_on_diag\",\n  max.size = 3\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nLet's do some more data visualization here. We'll move out of *Monocle 3* and into *ggplot2* to improve our flexibility with plotting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#add UMAP coordinates to the colData for easy plotting\nsasc$UMAP1 <- reducedDim(sasc, \"UMAP\")[,1]\nsasc$UMAP2 <- reducedDim(sasc, \"UMAP\")[,2]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#generate a distinguishable color scheme\nset.seed(1000)\ncolpal <- randomcoloR::distinctColorPalette(k=12)\n\nggplot(\n  data.frame(pData(sasc)), \n  aes(x=UMAP1, y=UMAP2, color=cell_type)) +\n  facet_wrap(~batch+donor) +\n  geom_point(size=0.5, alpha=0.5) +\n  theme_bw() +\n  scale_color_manual(values=colpal) +\n  theme(legend.position=\"bottom\", aspect.ratio = 1, panel.grid=element_blank()) +\n  guides(color = guide_legend(override.aes = list(size=8, alpha=1)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nFrom our visualizations, clusters 2, 3, 4, and 9 all appear to be related cell types - [ventricular cardiomyocytes](https://www.ptglab.com/news/blog/atrial-and-ventricular-myocytes/#:~:text=Atrial%20and%20ventricular%20cardiomyocytes%20form,and%20ion%20channels%20(2).).\n\nWe can also see across our four plots that we have clear evidence of both technical (batch) and biological (donor) variation!\n\n# 5. Quantifying a batch effect\n\nNow that we have evidence of a batch effect, let's quantify it! We'll make use of the *kBET* (k-nearest neighbor batch effect test) package from the [Theis lab](https://github.com/theislab/kBET?tab=readme-ov-file).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#kBET - k-nearest neighbour batch effect test\ndata <- reducedDim(sasc)\nbatch <- sasc$batch\n\nsubset_size <- 0.1 #subsample to 10% of the data for speed\nsubset_id <- sample.int(\n  n = length(batch), \n  size = floor(subset_size * length(batch)), \n  replace=FALSE\n)\n\nset.seed(1000)\nbatch.estimate <- kBET(\n  data[subset_id,], \n  batch[subset_id]\n) #this may take a few minutes\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbatch.estimate$summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      kBET.expected kBET.observed kBET.signif\nmean    0.002482853     0.9888066           0\n2.5%    0.000000000     0.9753086           0\n50%     0.002743484     0.9917695           0\n97.5%   0.006207133     1.0000000           0\n```\n\n\n:::\n:::\n\n\nBased on our rejection rate plot, it really does seem that we have a batch effect in our data. We can simulate a random batch assignment in our data and look at the same plot to convince ourselves of this observation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1000)\nrandombatch <- sample(sasc$batch, dim(sasc)[2])\nbatch.estimate.fake <- kBET(\n  data[subset_id,], \n  randombatch[subset_id]\n) #this may take a few minutes\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nAlright, so we clearly do have a batch effect!\n\n# 6. Batch correction\n\nSince we've proven that we have a batch effect in our data, let's perform batch correction using *Monocle 3*. We make use of the *align_cds* function, a wrapper built around the *reducedMNN* function from the *batchelor* package developed by the [Marioni Lab](https://www.ebi.ac.uk/research/marioni/) at the University of Cambridge.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Batch correction built-in to Monocle3\nset.seed(1000)\nbc_cds <- align_cds(\n  sasc, \n  alignment_group = \"batch\", \n  k = 50\n) #this may take a minute\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAligning cells from different batches using Batchelor.\nPlease remember to cite:\n\t Haghverdi L, Lun ATL, Morgan MD, Marioni JC (2018). 'Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors.' Nat. Biotechnol., 36(5), 421-427. doi: 10.1038/nbt.4091\n```\n\n\n:::\n\n```{.r .cell-code}\nbc_cds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: cell_data_set \ndim: 21286 24216 \nmetadata(2): cds_version citations\nassays(1): counts\nrownames(21286): ENSG00000238009 ENSG00000241860 ... ENSG00000278817\n  ENSG00000277196\nrowData names(6): id gene_short_name ... num_cells_expressed MT\ncolnames(24216): AGGATAATCTCGGCCTTACAGGTCAGCTT 22_60_95__s4 ...\n  24_87_10__s1 20_17_34__s4\ncolData names(16): barcode n.umi ... UMAP1 UMAP2\nreducedDimNames(3): PCA UMAP Aligned\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\nBased on our 'aligned' PCA, we can then call *reduce_dimensions* to generate a corresponding UMAP.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We can run reduce_dimensions to generate a UMAP from the 'aligned' PCA\nset.seed(1000)\nbc_cds <- reduce_dimension(\n  bc_cds, \n  reduction_method = \"UMAP\", \n  preprocess_method = \"Aligned\"\n)\n\nsasc$aligned_UMAP1 <- reducedDim(bc_cds, \"UMAP\")[,1] #save these in our original cds\nsasc$aligned_UMAP2 <- reducedDim(bc_cds, \"UMAP\")[,2] #save these in our original cds\n\nplot_cells(bc_cds, color_cells_by = \"batch\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo trajectory to plot. Has learn_graph() been called yet?\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nFinally, we use *kBET* again to quantitatively verify that we have removed our batch effect from our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Use kBET to quantitatively ask if it removes the batch effect\ndata <- reducedDim(bc_cds, \"UMAP\") #note that we are running this on the UMAP\nbatch <- bc_cds$batch\nsubset_size <- 0.1 #subsample to 10% of the data\nsubset_id <- sample.int(\n  n = length(batch), \n  size = floor(subset_size * length(batch)), \n  replace = FALSE\n)\n\nset.seed(1000)\nbatch.estimate <- kBET(\n  data[subset_id,], \n  batch[subset_id]\n) #this may take a few minutes\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n\n```{.r .cell-code}\nbatch.estimate$summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      kBET.expected kBET.observed kBET.signif\nmean     0.02403292     0.8678189           0\n2.5%     0.01574074     0.8291152           0\n50%      0.02331962     0.8683128           0\n97.5%    0.03364198     0.9012346           0\n```\n\n\n:::\n:::\n\n\nWhile the UMAP looks much better, the *kBET* metric is telling us that there is still a batch effect. If we run *kBET* on the 'aligned' PCs, the rejection rate is still close to 1. Is it possible we introduced artifacts through our batch correction? Let's try the *Harmony* package from the [Raychaudhuri Lab](https://immunogenomics.hms.harvard.edu) at Harvard and see if anything is different.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Batch correction with Harmony\nset.seed(1000)\nharm_cds <- RunHarmony(sasc, 'batch') #this may take a few minutes\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTransposing data matrix\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nInitializing state using k-means centroids initialization\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHarmony 1/10\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHarmony 2/10\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHarmony 3/10\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHarmony 4/10\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHarmony converged after 4 iterations\n```\n\n\n:::\n\n```{.r .cell-code}\nharm_cds #note the \"HARMONY\" in reducedDim\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: cell_data_set \ndim: 21286 24216 \nmetadata(2): cds_version citations\nassays(1): counts\nrownames(21286): ENSG00000238009 ENSG00000241860 ... ENSG00000278817\n  ENSG00000277196\nrowData names(6): id gene_short_name ... num_cells_expressed MT\ncolnames(24216): AGGATAATCTCGGCCTTACAGGTCAGCTT 22_60_95__s4 ...\n  24_87_10__s1 20_17_34__s4\ncolData names(18): barcode n.umi ... aligned_UMAP1 aligned_UMAP2\nreducedDimNames(3): PCA UMAP HARMONY\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n\n```{.r .cell-code}\nsasc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: cell_data_set \ndim: 21286 24216 \nmetadata(2): cds_version citations\nassays(1): counts\nrownames(21286): ENSG00000238009 ENSG00000241860 ... ENSG00000278817\n  ENSG00000277196\nrowData names(6): id gene_short_name ... num_cells_expressed MT\ncolnames(24216): AGGATAATCTCGGCCTTACAGGTCAGCTT 22_60_95__s4 ...\n  24_87_10__s1 20_17_34__s4\ncolData names(18): barcode n.umi ... aligned_UMAP1 aligned_UMAP2\nreducedDimNames(2): PCA UMAP\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Under the hood, Monocle 3 is using the uwot package to generate UMAPs\nharmony_umap <- umap(reducedDim(harm_cds, \"HARMONY\"), seed=1000) #this may take a minute\nsasc$harmony_UMAP1 <- harmony_umap[,1] #save these to our original cds\nsasc$harmony_UMAP2 <- harmony_umap[,2] #save these to our original cds\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Plot\nggplot(\n  data.frame(pData(sasc)), \n  aes(x = harmony_UMAP1, y = harmony_UMAP2, color = batch)) +\n  geom_point(size=0.5, alpha=0.5) +\n  theme_bw() + \n  scale_color_viridis(discrete=T, begin=0.1, end=0.9, option=\"A\") +\n  theme(legend.position=\"bottom\", aspect.ratio = 1, panel.grid=element_blank()) +\n  guides(color = guide_legend(override.aes = list(size = 8, alpha = 1)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Use kBET to quantitatively ask\ndata <- harmony_umap #note, we could alternatively run kBET at the level of the corrected PCs \nbatch <- harm_cds$batch\nsubset_size <- 0.1 #subsample to 10% of the data\nsubset_id <- sample.int(\n  n = length(batch),\n  size = floor(subset_size * length(batch)), \n  replace = FALSE)\n\nset.seed(1000)\nbatch.estimate <- kBET(data[subset_id,], batch[subset_id]) #this may take a few minutes\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n\n```{.r .cell-code}\nbatch.estimate$summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      kBET.expected kBET.observed kBET.signif\nmean    0.003004115     0.8504115           0\n2.5%    0.000000000     0.8106996           0\n50%     0.002743484     0.8518519           0\n97.5%   0.008230453     0.8973251           0\n```\n\n\n:::\n:::\n\n\nOnce again, our UMAP looks better, but our *kBET* metric suggests that it is still far from perfect.\n\nSo what benefit does batch correction offer? This is debatable, but certainly one thing it can do is help in identifying cell types. In our case, our toy dataset already had annotated cell types, but if we didn't know these ahead of time, batch correction could help us identify them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#cluster cells that have been aligned and plot these on our original UMAP\nbc_cds <- cluster_cells(\n  bc_cds, \n  k = 40, \n  cluster_method = \"leiden\", \n  random_seed = 1000\n) #this may take a few minutes\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsasc$aligned_clusters <- clusters(bc_cds) #save to original cds object\nsasc$aligned_partitions <- partitions(bc_cds) #save to original cds object\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data.frame(pData(sasc)), \n  aes(x = UMAP1, y = UMAP2, color = k40_leiden_clusters)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  theme_bw() + \n  scale_color_manual(values = colpal) +\n  theme(legend.position = \"bottom\", aspect.ratio = 1, panel.grid = element_blank()) +\n  guides(color = guide_legend(override.aes = list(size = 8, alpha = 1)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(colData(sasc)) %>%\n  group_by(cell_type) %>%\n  count(aligned_partitions) %>%\n  spread(aligned_partitions, n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 6\n# Groups:   cell_type [12]\n   cell_type                   `1`   `2`   `3`   `4`   `5`\n   <fct>                     <int> <int> <int> <int> <int>\n 1 Adipocyte                     1    NA    NA    63    NA\n 2 Atrial Cardiomyocyte          5    NA    NA    NA    NA\n 3 Cytoplasmic Cardiomyocyte  1368    16     3     2     3\n 4 Endothelium                2309     9   238    NA    31\n 5 Fibroblast                 2666     6     4    NA     1\n 6 Lymphocyte                  192    NA    NA    NA    NA\n 7 Macrophage                 1752     4    11    NA    NA\n 8 Neuronal                    445     4     2    NA    NA\n 9 Pericyte                    280   880     2     1    NA\n10 Unknown                    2981    71    34    15    17\n11 Vascular Smooth Muscle      116    87     1    NA    NA\n12 Ventricular Cardiomyocyte 10556    15     1    23     1\n```\n\n\n:::\n:::\n\n\nEven with our imperfect batch correction methods, our analysis has started to show us that some of our original clusters are related (ventricular cardiomyocytes).\n\n# 7. Differential gene expression\n\nWe are going to focus specifically on the ventricular cardiomyocytes for the rest of this code example. We start by subsetting our data down to ventricular cardiomyocytes that belong to clusters 2, 3, 4, and 9.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#combine batch and donor as a new column \nsasc$id <- paste(sasc$batch, sasc$donor, sep=\"_\")\n\n#subset ventricular cardiomyocyte data only \ncds_vent <- sasc[,sasc$cell_type == \"Ventricular Cardiomyocyte\" &\n                   sasc$k40_leiden_clusters %in% c(\"2\", \"3\", \"4\", \"9\")]\n```\n:::\n\n\nDifferential expression analysis can take a long time, so we will run the following code on a subset of pre-defined genes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_list <- c(\"LINC00486\", \"TTN\", \"LINC-PINT\", \"TAS2R14\", \"MT-CO1\",\n               \"MT-ND4\", \"FN1\", \"LAMA2\", \"XIST\", \"PDK4\", \"ZBTB16\",\n               \"PPP1R3E\", \"TMTC1\", \"NT5DC3\", \"RBX1\", \"MRPL45\", \"ESR2\",\n               \"TUBGCP4\", \"MYH7\", \"MYL2\", \"MB\", \"ACTC1\", \"TPM1\", \"MYH6\")\n\ncds_subset <- cds_vent[rowData(cds_vent)$gene_short_name %in% gene_list,]\n```\n:::\n\n\nWe now plot expression levels of these genes, split by donor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_genes_violin(cds_subset, group_cells_by = \"donor\", ncol = 4) +\n  theme(axis.text.x=element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in scale_y_log10(): log-10 transformation introduced infinite values.\nlog-10 transformation introduced infinite values.\nlog-10 transformation introduced infinite values.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 108135 rows containing non-finite outside the scale range\n(`stat_ydensity()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 108135 rows containing non-finite outside the scale range\n(`stat_summary()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\nIt is clear that some of our genes are differentially expressed across our two donors. How do we tell what contribution comes from donors and what comes from assay batch? Let's build models for our data and compare.\n\nIn the donor model, we assume there are no batch effects and the only contributing variable is *donor.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndonor_model <- fit_models(\n  cds_subset,\n  model_formula_str = \"~donor\",\n  expression_family=\"negbinomial\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefficient_table(donor_model) %>% \n  filter(term == \"donor1\") %>%\n  filter(q_value < 0.05) %>%\n  select(id, gene_short_name, term, q_value, estimate) %>%\n  arrange(gene_short_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 5\n   id              gene_short_name term     q_value estimate\n   <chr>           <chr>           <chr>      <dbl>    <dbl>\n 1 ENSG00000159251 ACTC1           donor1 5.46e-125   0.671 \n 2 ENSG00000115414 FN1             donor1 0           2.40  \n 3 ENSG00000196569 LAMA2           donor1 2.56e- 88  -0.245 \n 4 ENSG00000231721 LINC-PINT       donor1 1.67e-258  -1.91  \n 5 ENSG00000230876 LINC00486       donor1 4.42e-217   1.14  \n 6 ENSG00000198125 MB              donor1 1.38e- 55   0.463 \n 7 ENSG00000198804 MT-CO1          donor1 2.12e-214   1.23  \n 8 ENSG00000198886 MT-ND4          donor1 1.25e-170   1.13  \n 9 ENSG00000092054 MYH7            donor1 1.46e-107  -0.460 \n10 ENSG00000111245 MYL2            donor1 1.76e- 22   0.299 \n11 ENSG00000004799 PDK4            donor1 5.25e- 29  -0.165 \n12 ENSG00000212127 TAS2R14         donor1 6.18e-155  -3.80  \n13 ENSG00000155657 TTN             donor1 2.41e- 24  -0.0999\n14 ENSG00000229807 XIST            donor1 1.59e-167  -5.55  \n15 ENSG00000109906 ZBTB16          donor1 3.44e-178  -0.579 \n```\n\n\n:::\n:::\n\n\nIn our second model, we include batch effects as a predictor variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#controlling for batch effects\ndonor_batch_model <- fit_models(\n  cds_subset,\n  model_formula_str = \"~donor + batch\",\n  expression_family=\"negbinomial\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefficient_table(donor_batch_model) %>% \n  filter(term == \"donor1\") %>%\n  filter(q_value < 0.05) %>%\n  select(id, gene_short_name, term, q_value, estimate) %>%\n  arrange(gene_short_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 5\n   id              gene_short_name term     q_value estimate\n   <chr>           <chr>           <chr>      <dbl>    <dbl>\n 1 ENSG00000159251 ACTC1           donor1 6.11e-  6   0.165 \n 2 ENSG00000115414 FN1             donor1 2.00e-200   2.37  \n 3 ENSG00000196569 LAMA2           donor1 3.44e- 72  -0.275 \n 4 ENSG00000231721 LINC-PINT       donor1 3.45e-  2   0.228 \n 5 ENSG00000198125 MB              donor1 4.23e-  2  -0.0950\n 6 ENSG00000198804 MT-CO1          donor1 4.17e- 43   0.605 \n 7 ENSG00000198886 MT-ND4          donor1 1.48e- 21   0.422 \n 8 ENSG00000197616 MYH6            donor1 6.76e- 23   0.303 \n 9 ENSG00000092054 MYH7            donor1 7.85e- 16  -0.215 \n10 ENSG00000111245 MYL2            donor1 1.12e- 13   0.299 \n11 ENSG00000004799 PDK4            donor1 5.56e-243  -0.534 \n12 ENSG00000212127 TAS2R14         donor1 9.17e-  3  -0.527 \n13 ENSG00000155657 TTN             donor1 2.00e- 36   0.142 \n14 ENSG00000229807 XIST            donor1 1.15e-167  -5.56  \n15 ENSG00000109906 ZBTB16          donor1 3.01e-  3  -0.0961\n```\n\n\n:::\n:::\n\n\nComparing these two models, we can see that some of our genes are significantly influenced by the introduction of batch as a predictor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Comparing models of gene expression\ncompare_models(donor_batch_model, donor_model) %>% \n  select(gene_short_name, q_value) %>% \n  data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   gene_short_name       q_value\n1        LINC00486  0.000000e+00\n2              TTN 4.329415e-286\n3              FN1  1.000000e+00\n4            LAMA2  1.020045e-02\n5             PDK4  0.000000e+00\n6        LINC-PINT  0.000000e+00\n7           ZBTB16 6.655693e-187\n8          TAS2R14  0.000000e+00\n9            TMTC1  2.872632e-05\n10          NT5DC3  5.740679e-02\n11            MYL2  1.000000e+00\n12         PPP1R3E  4.636225e-01\n13            MYH6  1.999277e-62\n14            MYH7  5.726891e-61\n15            ESR2  2.311010e-02\n16           ACTC1 4.529192e-170\n17         TUBGCP4  5.352325e-01\n18            TPM1  9.684985e-01\n19          MRPL45  1.000000e+00\n20              MB 4.086623e-205\n21            RBX1  1.000000e+00\n22            XIST  1.000000e+00\n23          MT-CO1 7.757731e-279\n24          MT-ND4  0.000000e+00\n```\n\n\n:::\n:::\n\n\nLet's take a closer look at two example genes: LINC00486 and TTN, both of which have highly significant [*q*-values](https://en.wikipedia.org/wiki/Q-value_(statistics)) (close to 0).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get normalized counts\ncntmtx <- normalized_counts(cds_subset)\ncds_subset$LINC00486 <- cntmtx[\"ENSG00000230876\",]\ncds_subset$TTN <- cntmtx[\"ENSG00000155657\",]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#the case of LINC00486\na <- ggplot(\n  data.frame(pData(cds_subset)), \n  aes(x = donor, y = LINC00486)) + \n  geom_violin(aes(fill = donor)) +\n  geom_boxplot(width = 0.2, fill = \"white\", alpha = 0.3, outlier.shape = NA) +\n  theme_bw() \n\nb <- ggplot(\n  data.frame(pData(cds_subset)), \n  aes(x = batch, y = LINC00486)) + \n  geom_violin(aes(fill = \"salmon\")) +\n  geom_boxplot(width=0.2, fill = \"white\", alpha = 0.3, outlier.shape = NA) +\n  theme_bw() \n\nc <- ggplot(\n  data.frame(pData(cds_subset)), \n  aes(x = id, y = LINC00486, fill = donor)) + \n  geom_violin() +\n  geom_boxplot(width=0.2, fill = \"white\", alpha = 0.3, outlier.shape = NA) +\n  theme_bw() \n\nplot_grid(a + theme(legend.position = \"none\"),\n          b + theme(legend.position = \"none\") + ylab(\"\"),\n          c + theme(legend.position = \"none\") + ylab(\"\"), \n          labels=c(\"A\", \"B\", \"C\"),\n          nrow = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\nFrom our model, we can see that the batch variable was the primary contributor to differences in LINC00486 expression across our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefficient_table(donor_model) %>% \n  filter(gene_short_name == \"LINC00486\" & term ==\"donor1\") %>%\n  select(id, gene_short_name, term, q_value, estimate) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  id              gene_short_name term     q_value estimate\n  <chr>           <chr>           <chr>      <dbl>    <dbl>\n1 ENSG00000230876 LINC00486       donor1 4.42e-217     1.14\n```\n\n\n:::\n\n```{.r .cell-code}\ncoefficient_table(donor_batch_model) %>% \n  filter(gene_short_name == \"LINC00486\" & term %in% c(\"donor1\", \"batchScale\")) %>%\n  select(id, gene_short_name, term, q_value, estimate) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  id              gene_short_name term       q_value estimate\n  <chr>           <chr>           <chr>        <dbl>    <dbl>\n1 ENSG00000230876 LINC00486       donor1           1   0.0133\n2 ENSG00000230876 LINC00486       batchScale       0   3.64  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#the case of TNN\nx <- ggplot(\n  data.frame(pData(cds_subset)), \n  aes(x = donor, y = TTN)) + \n  geom_violin(aes(fill = donor)) +\n  geom_boxplot(width = 0.2, fill = \"white\", alpha = 0.3, outlier.shape = NA) +\n  theme_bw() \n\ny <- ggplot(\n  data.frame(pData(cds_subset)), \n  aes(x = batch, y = TTN)) + \n  geom_violin(aes(fill = \"salmon\")) +\n  geom_boxplot(width = 0.2, fill = \"white\", alpha = 0.3, outlier.shape = NA) +\n  theme_bw() \n\nz <- ggplot(\n  data.frame(pData(cds_subset)), \n  aes(x = id, y = TTN, fill = donor)) + \n  geom_violin() +\n  geom_boxplot(width = 0.2, fill = \"white\", alpha = 0.3, outlier.shape = NA) +\n  theme_bw() \n\nplot_grid(\n  x + theme(legend.position=\"none\"),\n  y + theme(legend.position=\"none\") + ylab(\"\"),\n  z + theme(legend.position=\"none\") + ylab(\"\"), \n  labels=c(\"A\", \"B\", \"C\"),\n  nrow = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n:::\n\n\nOn the other hand, in the case of TTN, we see that both donor and batch affected its expression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefficient_table(donor_model) %>% \n  filter(gene_short_name == \"TTN\" & term ==\"donor1\") %>%\n  select(id, gene_short_name, term, q_value, estimate) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  id              gene_short_name term    q_value estimate\n  <chr>           <chr>           <chr>     <dbl>    <dbl>\n1 ENSG00000155657 TTN             donor1 2.41e-24  -0.0999\n```\n\n\n:::\n\n```{.r .cell-code}\ncoefficient_table(donor_batch_model) %>% \n  filter(gene_short_name == \"TTN\" & term %in% c(\"donor1\", \"batchScale\")) %>%\n  select(id, gene_short_name, term, q_value, estimate) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  id              gene_short_name term        q_value estimate\n  <chr>           <chr>           <chr>         <dbl>    <dbl>\n1 ENSG00000155657 TTN             donor1     2.00e-36    0.142\n2 ENSG00000155657 TTN             batchScale 0          -0.405\n```\n\n\n:::\n:::\n\n\n# 8. Key takeaways and suggestions\n\n-   Do not blindly apply batch correction! You risk introducing more artifacts than you remove.\n\n-   In general, it is better to use batch correction methods for data exploration and visualization rather than analysis.\n\n-   If you have a batch effect, model it in your downstream analysis (i.e include it as a covariate) instead of modifying your data directly.\n\n# 9. Conclusions\n\nThis concludes the content that was covered in the SASC User Group workshop on batch correction. I'd like to give a huge thank you again to Mary and the team at the BBI for organizing this tutorial and sharing it freely with the public! I look forward to covering more from these meetings in the future, as well as sharing my own thoughts and exploration of single cell data down the road.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}